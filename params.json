{"name":"Fractalis","tagline":"","body":"Projet Fractales\r\n======\r\n\r\nVisionneur de fractales, développé dans le cadre du BE d'informatique de Phelma.\r\n\r\nContributeurs :\r\n\r\n> Julia Dupuis\r\n\r\n> Nils Exibard\r\n\r\n> Félix Piédallu\r\n\r\n## 1. Structure des données fonctionnelles\r\n\r\n### Définition des données fonctionnelles dans ``u4-fonctions.h``\r\n```c++\r\n// Profondeur max à vérifier (Maximum du réglage utilisateur)\r\n#define PROFONDEUR_MAX 10000\r\n// Données utilisateurs initiales :\r\n    // Type de fractale initiale (au lancement du logiciel)\r\n#define FRACT_INIT MANDELBROT\r\n    // Rang de convergence\r\n#define RANGMAX_INIT    250\r\n    // Module maximal de convergence\r\n#define MODULEMAX_INIT  2\r\n    // Constante de calcul initiale\r\n#define C_INIT  (1,1)\r\n    //Position initiale de la fenêtre sur le plan complexe\r\n#define IG_INIT (1,1)\r\n#define SD_INIT (2,2)\r\n    // Taille du tableau, à ne pas modifier normalement : (=Taille de la fenêtre d'affichage en pixels)\r\n#define HAUTEUR 400\r\n#define LARGEUR 600\r\n\r\n    // Type de fractale initiale (au lancement du logiciel)\r\ntypedef std::complex<double> (*pointeurFct)(std::complex<double>, std::complex<double>);\r\n\r\n    // Type énuméré définissant les fractales possibles\r\nenum fractype {\r\n    MANDELBROT,\r\n    JULIA,\r\n    PERSONNA\r\n};\r\n\r\n    // Structure de Pixels contenus dans un tableau\r\nstruct Pixel {\r\n    std::complex<double> z; // Coordonnées dans le plan std::complexe\r\n    int n;  // rang de divergence\r\n};\r\n\r\n    // Structure des paramètres utilisateur\r\nstruct Donnees {\r\n    enum fractype Fractale;     // Type de fractales choisie\r\n    int     rangMax;            // Rang de convergence\r\n    double  moduleMax;          // Module de convergence (détermination de la convergence on non de la fonction)\r\n    std::complex<double> C;     // Constante de calcul\r\n    std::complex<double> ig;    // Coordonnées du point inférieur gauche\r\n    std::complex<double> sd;    // Coordonnées du point haut droit\r\n    struct Pixel Tab[HAUTEUR][LARGEUR]; // Matrice des pixels de l'image.\r\n};\r\n```\r\n\r\n## 2. Structure des données de l’interface graphique\r\n\r\n### Esquisse de l’interface :\r\n### Définition des données de l’interface graphique dans ``u2-fonctions.h``\r\n\r\n```c++\r\n// Declaration des objets de l'interface\r\nstruct Interface {\r\n    Fl_Double_Window*Fenetre;       // Fenêtre du projet\r\n    DrawingArea* ZoneDessin;        // Zone de dessin\r\n    Fl_Button* BoutonQuitter;       // Quitter le programme\r\n    Fl_Button* BoutonEnregistrer;   // Enregistrer l'image\r\n    Fl_Button* BoutonSauvePosition; // Enregistrer les paramètres actuels\r\n    Fl_Button* BoutonReset;         // Revenir aux paramères par défaut\r\n    Fl_Value_Input*ModuleDeSortie;  // Module de sortie\r\n    Fl_Value_Input*Profondeur;      // Profondeur\r\n    Fl_Choice* TypeFractale;        // Type de fractale\r\n    Fl_Button*ZoomPlus;             // Zoomer\r\n    Fl_Button*ZoomMoins;            // Dézoomer\r\n};\r\n```\r\n\r\n### Définition des callbacks associées aux objets de l’interface dans ``u3-fonctions.h``\r\n```c++\r\n    // Prototypes des callbacks\r\nvoid ModuleDeSortieCB   (Fl_Widget* w, void* data);\r\nvoid ProfondeurCB       (Fl_Widget* w, void* data);\r\nvoid FractaleCB         (Fl_Widget* w, void* data);\r\nvoid BoutonQuitterCB    (Fl_Widget* w, void* data);\r\nvoid BoutonEnregistrerCB(Fl_Widget* w, void* data);\r\n\r\n    // On peut utiliser de préférence la souris, sinon :\r\nvoid BoutonZoomPlusCB   (Fl_Widget* w, void* data);\r\nvoid BoutonZoomMoinsCB  (Fl_Widget* w, void* data);\r\n```\r\n\r\n## 3. Fonctions de calcul et d'affichage, définies dans ``u4-fonctions.cpp``\r\n```c++\r\nvoid Initialiser ();\r\n    // Inialiser l'interface avec un premier affichage avec les paramètres par défaut\r\n\r\nvoid Affichage();\r\n    // Affiche la fractale dans la zone de dessin\r\n\r\nvoid calcule(struct Donnee);\r\n    // Calcule la fractale et retourne les profondeurs.\r\n\r\nCalculeCouleurs(struct Donnee);\r\n\r\n    // Initialisation des données, effectué au démarrage du programme ou au reset des paramètres\r\nvoid InitialiserDonnees() ;\r\n\r\n    //int couleurN(int N);    // Sort une couleur à partir d'un N. Géré par Nils ?\r\n\r\n    // Fonction de test, utilisée pour tester sans l'affichage des paramètres sensibles\r\nint testFonction();\r\n\r\n    // Pointe vers la fonction fractale utilisée. Permet de gérer plus facilement les différents types.\r\npointeurFct retourne_fonction();\r\n\r\n    // Donne un rang de convergence pour un point du plan complexe et une fonction\r\nint convergence(std::complex<double> position, pointeurFct);\r\n\r\n    // Fonctions fractales, prenant en entrée la position de calcul et le terme Zn de calcul de convergence\r\nstd::complex<double> mandelbrot(std::complex<double> position, std::complex<double> z);\r\nstd::complex<double> julia     (std::complex<double> position, std::complex<double> z);\r\nstd::complex<double> personna  (std::complex<double> position, std::complex<double> z);\r\n\r\n    // Fonctions de conversion Position dans le tableau -- Position sur le plan complexe\r\n    // (Demande des pointeurs car 2 valeurs à ressortir)\r\nvoid tableauFromComplex(std::complex<double> position, int* x, int* y);\r\n\r\nstd::complex<double> position complexFromTableau(int x, int y);\r\n\r\n```\r\n\r\n##4. Directions :\r\n\r\n*Dans un premier temps*, il s'agira de déveloper un projet assez simple, permettant d'afficher les quatre types de fractale définies dans le sujet.\r\nLe travail sur la couleur sera effectué uniquement entre deux couleurs choisies par l'utilisateur.\r\nNous réaliserons également un zoom basique et un enregistrement au fomat PPM de l'image, ainsi que des paramètres choisis dans un fichier texte.\r\nL'interface devra être complète et attractive pour l'utilisateur .\r\n\r\n\r\n*Dans un second temps*, nous pourrons ajouter des fonctionnalités avancées, telles que :\r\n\r\n* Zoom plus efficace (upscaling puis recalcul)\r\n* Bon système de couleurs, avec points de contrôle et fonction d'interpolation non linéaire (quadratique,…)\r\n* Changement progressif de couleur (animation)\r\n* Meilleure qualité d'enregistrement d'images (meilleure que l'affichage)\r\n* Fractales 3D\r\n* Interface plus conviviale (changement de couleur graphique si possible,…)\r\n* Enregistrement des paramètres dans un fichier texte. (Zooms et positions actuelles)\r\n* Fonction éditable par l'utilisateur\r\n\r\n\r\nRépartition des taches :\r\n> Nils :gestion des couleurs\r\n\r\n> Félix : Fonctions et définitions\r\n\r\n> Julia : Interface et Callbacks\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}